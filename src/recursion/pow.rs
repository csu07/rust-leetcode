/*
https://leetcode-cn.com/problems/powx-n
实现pow( a,n )，即计算 a的 n次幂函数。
(1)说明
1)-100.0< <100.0
2) 是32位有符号整数，其数值范围是[-231, 231-1]。 (2)示例
输入:2.00000, 10
输出:1024.00000
输入:2.10000, 3
输出:9.26100
输入:2.00000, -2
输出:0.25000

(1)算法原理
根据分治算法，要想得到 的结果，可以先求 /2的结果，每次 递归都会使得指数值减少一半。
1)如果 为偶数， = /2× /2。比如，计算 32可以按照32→ x16→ x8→ x4→ x2→ x的顺序依次拆解，即 32= x16× x16，
16= 8× 8， 4= 2× 2， 2= × ，通过5次拆解计算可以得到 32的 值，而不需要对 做32次的乘法计算。
2)如果 为奇数， ，其中   表示对 /2 进行下取整。比如，计算 31可以按照 31→ 15→ 7→ 3→ 的顺序依次

 */

pub fn my_pow(x: f64, n: i32) -> f64 {
    let mut x = x;
    let mut n = n;
    if n < 0 {
        x = 1.0/x;
        n = -n;
    }
    return pow_recursion(x, n);
}

fn pow_recursion(x:f64, n:i32) -> f64{
    // 递归终止条件
   if n == 0 {
       return 1.0;

   }
    // 对应模板:处理当前层逻辑，将问题拆分为子问题
    // 对应模板:下探到下一层，求解子问题
    let half = pow_recursion(x, n/2);

    // 对应模板:将子问题的结果合并成原问题的解
    return if n % 2 == 0 {
        half * half
    }else { half * half * x }
}